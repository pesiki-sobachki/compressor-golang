# Резюме и план: Проект "Модульный компрессор файлов на Go"

Этот документ обобщает техническое задание и принятые решения для разработки сервиса компрессии файлов на языке Go. Он служит отправной точкой для начала работы.

## 1. Исходная задача (Ключевые требования)

- **Основная функция:** Разработать сервис для компрессии файлов, начиная с изображений, но с возможностью поддержки других форматов в будущем.
- **Два режима работы:**
    1.  **Встраиваемый пакет (library):** для использования в других Go-проектах.
    2.  **Самостоятельный HTTP-сервер:** предоставляющий API для компрессии.
- **Архитектурное требование:** Строго следовать гексагональной архитектуре ("Порты и Адаптеры").
- **Ключевые принципы:** Максимальная гибкость, модульность, надежность и масштабируемость. Без упрощений.

## 2. Предложенная концепция и архитектура

Предложена классическая **гексагональная архитектура** для изоляции бизнес-логики от внешних зависимостей.

- **Ядро (Домен):** `internal/domain` и `internal/app/service`
    - Содержит чистую бизнес-логику и модели данных.
- **Порты (Интерфейсы):** `internal/app/port`
    - Абстрактные контракты (Go interfaces), которые определяют, *что* система может делать (`Processor`, `FileRepository`).
- **Адаптеры:** `internal/adapter`
    - Конкретные реализации портов, связывающие ядро с внешним миром (HTTP-обработчики, реализация компрессора, хранилища).

## 3. Предлагаемая файловая структура

За основу взята структура `Standard Go Project Layout`.

```
/
├── cmd/
│   └── compressor-server/
│       └── main.go              # Точка входа для HTTP-сервера
├── internal/
│   ├── app/                     # Ядро приложения
│   │   ├── service/             # Оркестрация бизнес-логики (CompressionService)
│   │   └── port/                # Интерфейсы (порты)
│   ├── domain/
│   │   ├── file.go              # Доменная модель файла
│   │   └── errors.go            # Пользовательские ошибки
│   └── adapter/                 # Реализации (адаптеры)
│       ├── handler/http/        # HTTP обработчик (Gin, Fiber, etc.)
│       ├── repository/
│       │   ├── local/           # Хранение на диске
│       │   └── s3/              # Хранение в S3
│       └── processor/
│           ├── image/           # Компрессия изображений (bimg)
│           └── text/            # Компрессия текста (gzip)
├── pkg/
│   └── compressor/
│       └── client.go            # Клиентская библиотека (API для пакета)
└── go.mod
```

## 4. Ключевые интерфейсы (Контракты ядра)

1.  **`Processor`**: Абстрагирует любой алгоритм компрессии.
    ```go
    type Processor interface {
        Process(inputFile File, opts Options) (File, error)
        Supports(mimeType string) bool
    }
    ```
2.  **`FileRepository`**: Абстрагирует любое хранилище файлов.
    ```go
    type FileRepository interface {
        Save(ctx context.Context, file File, path string) (string, error)
        Get(ctx context.Context, path string) (File, error)
    }
    ```

## 5. Рекомендованный технологический стек

- **HTTP-сервер:** **Gin** или **Fiber** (либо `net/http`).
- **Компрессия изображений:** **bimg** (требует установки `libvips` в системе).
- **Конфигурация:** **Viper**.
- **Логирование:** **slog** (стандартная библиотека с Go 1.21).

## 6. План по расширяемости

- **Новый алгоритм компрессии:** Создать новый адаптер, реализующий `port.Processor`, и зарегистрировать его в сервисе.
- **Новый тип хранилища:** Создать новый адаптер, реализующий `port.FileRepository`, и подменить его при инициализации приложения.

## 7. Утвержденные решения и план первых шагов

### Утвержденные решения

1.  **Сборка зависимостей (DI):** Начинаем с **ручной сборки** зависимостей в функции `main()` пакета `cmd/compressor-server`. Это позволит лучше понять связи в приложении. В будущем, при усложнении проекта, возможен переход на DI-контейнер (например, `google/wire`).

2.  **Дизайн API:** На первом этапе реализуется простой **синхронный API**.
    - **Эндпоинт:** `POST /compress`
    - **Запрос:** `multipart/form-data` с полем для файла (`file`) и полями для опций компрессии (`quality`, `format`).
    - **Ответ:** В случае успеха (`200 OK`), в теле ответа возвращаются **бинарные данные** сжатого файла с соответствующим `Content-Type`.
    - *Примечание: Асинхронный API (с задачами и проверкой статуса) — возможное улучшение в будущем.*

3.  **Стратегия хранения файлов:** Имена файлов и пути генерируются программно для обеспечения безопасности и уникальности.
    - **Имя файла:** Генерируется на основе **UUID v4**.
    - **Структура каталогов:** На основе даты загрузки, например: `storage/YYYY/MM/DD/`.
    - **Итоговый путь:** `storage/2025/11/17/a1b2c3d4-e5f6-....-g7h8i9j0.webp`.
    - *Примечание: Это позволяет избежать уязвимостей и коллизий, связанных с использованием оригинальных имен файлов.*

### План реализации (первые шаги)

1.  **Настройка окружения:** Установить Go и внешнюю зависимость `libvips`.
2.  **Создание структуры проекта:** Инициализировать Go-модуль и создать структуру каталогов согласно плану.
3.  **Реализация ядра:** Начать с написания кода, не имеющего зависимостей:
    - Модели в `internal/domain`.
    - Интерфейсы в `internal/app/port`.
4.  **Написание первых адаптеров:**
    - Реализовать `FileRepository` для сохранения на локальный диск (`internal/adapter/repository/local`).
    - Реализовать `Processor` для компрессии изображений с использованием `bimg` (`internal/adapter/processor/image`).
5.  **Сборка и запуск:**
    - В `cmd/compressor-server/main.go` "собрать" все компоненты вместе (создать экземпляры репозитория, процессора, сервиса и обработчика).
    - Запустить HTTP-сервер с одним эндпоинтом `/compress`, который использует созданные компоненты.